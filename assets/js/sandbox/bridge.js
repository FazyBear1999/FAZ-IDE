// assets/js/sandbox/bridge.js
// Script injected into the sandboxed iframe.
// Captures:
// - console.log/warn/error/info
// - window error events
// - unhandled promise rejections
//
// Security:
// - Parent generates a per-run token
// - Iframe includes token in every message
// - Parent ignores any message that doesn't match token
//
// Notes:
// - This returns an HTML string containinf a <script> tag. The parent writes it
//   into the iframe so user code runs in an isolated context.
// - Communication uses postMessage(). We include {source, token} so the parent
//   can filter out unrelated messages.
// - Using "*" as targetOrigin is acceptable here ONLY because we also verify
//   a per-run token on the receiving side. (Origin checks can be added later.)
// - We escape the closing script tag (<\/script>) so this template string can
//   safely contain a <script> without prematurely terminating.

export function bridgeScript(token) {
    // `token` is generated by the parent for each run.
    // JSON.stringify ensures the token is safely embedded as a JS string literal.
    return `
    <script>
        const TOKEN = ${JSON.stringify(token)};
        const MAX_CONSOLE_ARGS = 120;
        const MAX_CONSOLE_PART_CHARS = 1600;
        const MAX_CONSOLE_DEPTH = 2;
        const send = (type, payload) => {
            // Post a structured message to the parent window.
            // Parent should validate: source === "fazide" AND token matches.
            try {
                parent.postMessage({ source: "fazide", token: TOKEN, type, payload }, "*");
            } catch (err) {
                if (type === "bridge_error") return;
                try {
                    parent.postMessage({
                        source: "fazide",
                        token: TOKEN,
                        type: "bridge_error",
                        payload: { message: String(err && err.message ? err.message : err) }
                    }, "*");
                } catch (_bridgeErr) {}
            }
        };

        const trimText = (value, maxChars = MAX_CONSOLE_PART_CHARS) => {
            const source = String(value ?? "");
            const limit = Math.max(64, Number(maxChars) || MAX_CONSOLE_PART_CHARS);
            if (source.length <= limit) return source;
            return source.slice(0, limit - 15) + " ... [truncated]";
        };

        const describeElement = (value) => {
            if (typeof Element === "undefined" || !(value instanceof Element)) return "";
            const tag = String(value.tagName || "element").toLowerCase();
            const idPart = value.id ? "#" + value.id : "";
            const classPart = value.classList && value.classList.length
                ? "." + Array.from(value.classList).slice(0, 2).join(".")
                : "";
            return "<" + tag + idPart + classPart + ">";
        };

        const toConsoleString = (value, depth = 0, seen = null) => {
            if (value === null || value === undefined) return String(value);
            if (typeof value === "string") return value;
            if (typeof value === "number" || typeof value === "boolean" || typeof value === "bigint") return String(value);
            if (typeof value === "symbol") return String(value);
            if (typeof value === "function") return value.name ? "[Function " + value.name + "]" : "[Function]";
            if (value instanceof Error) return value.stack || value.message || String(value);

            const elementLabel = describeElement(value);
            if (elementLabel) return elementLabel;

            if (depth >= MAX_CONSOLE_DEPTH) return "[Object]";
            const nextSeen = seen || (typeof WeakSet !== "undefined" ? new WeakSet() : null);
            if (nextSeen && typeof value === "object") {
                if (nextSeen.has(value)) return "[Circular]";
                nextSeen.add(value);
            }

            if (Array.isArray(value)) {
                const preview = value.slice(0, 20).map((entry) => trimText(toConsoleString(entry, depth + 1, nextSeen), 180));
                const suffix = value.length > 20 ? ", ..." : "";
                return "[" + preview.join(", ") + suffix + "]";
            }

            if (typeof value === "object") {
                const allKeys = Object.keys(value);
                const keys = allKeys.slice(0, 20);
                const preview = keys.map((key) => {
                    let child;
                    try {
                        child = value[key];
                    } catch (err) {
                        child = "[Thrown: " + String(err && err.message ? err.message : err) + "]";
                    }
                    return key + ": " + trimText(toConsoleString(child, depth + 1, nextSeen), 180);
                });
                const suffix = allKeys.length > keys.length ? ", ..." : "";
                return "{ " + preview.join(", ") + suffix + " }";
            }

            try {
                return String(value);
            } catch {
                return "[Unserializable]";
            }
        };

        const sanitizeConsoleArgs = (args) => {
            const list = Array.isArray(args) ? args : [args];
            const limited = list
                .slice(0, MAX_CONSOLE_ARGS)
                .map((entry) => trimText(toConsoleString(entry), MAX_CONSOLE_PART_CHARS));
            if (list.length > MAX_CONSOLE_ARGS) {
                limited.push("... [" + String(list.length - MAX_CONSOLE_ARGS) + " argument(s) skipped in sandbox bridge]");
            }
            return limited;
        };

        // Patch console.* to forward logs to parent
        ["log","warn","error","info"].forEach((m) => {
            // Preserve original behavior so logs still appear in the iframe console (devtools)
            const orig = console[m].bind(console);

            // Replace console method: call original, then forward args to parent
            console[m] = (...args) => {
                orig(...args);
                const safeArgs = sanitizeConsoleArgs(args);
                send("console", { level: m, args: safeArgs });
            };
        });

        // Runtime errors (synchronous exceptions, script errors, etc.)
        window.addEventListener("error", (e) => {
            // Forward the basic location info so the UI can show where it happened.
            // (Stack traces can be added later, but be careful about browser differences.)
            send("runtime_error", {
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno
            });
        });

        // Unhandled promise rejections (async errors)
        window.addEventListener("unhandledrejection", (e) => {
            // Many rejection reasons are objects; String(...) normalizes to something printable.
            // If you want richer detail later, you can attempt JSON.stringify with fallback.
            send("promise_rejection", { reason: String(e.reason) });
        });

        let inspectActive = false;
        let highlightEl = null;
        let hoverHandler = null;
        let clickHandler = null;
        let rafId = null;
        let pendingNode = null;
        let lastInspectSignature = "";
        const THEME_SURFACE = {
            dark: { background: "#0b0f14", foreground: "#e6edf3", colorScheme: "dark" },
            light: { background: "#f8fafc", foreground: "#0f172a", colorScheme: "light" },
            purple: { background: "#140b24", foreground: "#f3e8ff", colorScheme: "dark" },
            retro: { background: "#10150f", foreground: "#e6f1d1", colorScheme: "dark" },
            temple: { background: "#0f3fc6", foreground: "#fef7e6", colorScheme: "dark" }
        };

        const normalizeTheme = (value) => {
            const key = String(value || "").toLowerCase();
            return THEME_SURFACE[key] ? key : "dark";
        };

        const applyThemeSurface = (themeValue) => {
            const theme = normalizeTheme(themeValue);
            const surface = THEME_SURFACE[theme];
            const root = document.documentElement;
            const body = document.body;
            if (root) {
                root.style.setProperty("color-scheme", surface.colorScheme);
                root.style.setProperty("background", surface.background, "important");
                root.style.setProperty("background-color", surface.background, "important");
            }
            if (body) {
                body.style.setProperty("margin", "0", "important");
                body.style.setProperty("min-height", "100%", "important");
                body.style.setProperty("background", surface.background, "important");
                body.style.setProperty("background-color", surface.background, "important");
                body.style.setProperty("color", surface.foreground);
            }
            return theme;
        };

        const ensureHighlight = () => {
            if (highlightEl) return highlightEl;
            highlightEl = document.createElement("div");
            highlightEl.dataset.fazideHighlight = "true";
            highlightEl.style.position = "fixed";
            highlightEl.style.zIndex = "2147483647";
            highlightEl.style.pointerEvents = "none";
            highlightEl.style.border = "1px solid rgba(46, 233, 166, 0.9)";
            highlightEl.style.background = "rgba(46, 233, 166, 0.20)";
            highlightEl.style.boxShadow = "0 0 0 1px rgba(10, 14, 26, 0.6)";
            highlightEl.style.display = "none";
            (document.body || document.documentElement).appendChild(highlightEl);
            return highlightEl;
        };

        const hideHighlight = () => {
            if (highlightEl) highlightEl.style.display = "none";
        };

        const describeSelector = (node) => {
            if (!node || node.nodeType !== 1) return "";
            const parts = [];
            let current = node;
            let depth = 0;
            while (current && depth < 7 && current.nodeType === 1) {
                const tag = String(current.tagName || "").toLowerCase();
                if (!tag) break;
                let part = tag;
                if (current.id) {
                    part += "#" + current.id;
                    parts.unshift(part);
                    break;
                }
                const classes = Array.from(current.classList || [])
                    .map((entry) => String(entry || "").trim())
                    .filter(Boolean)
                    .slice(0, 2);
                if (classes.length) {
                    part += "." + classes.join(".");
                }
                const parent = current.parentElement;
                if (parent) {
                    const peers = Array.from(parent.children || []).filter((entry) => entry.tagName === current.tagName);
                    if (peers.length > 1) {
                        const idx = peers.indexOf(current);
                        if (idx >= 0) part += ":nth-of-type(" + String(idx + 1) + ")";
                    }
                }
                parts.unshift(part);
                current = parent;
                depth += 1;
            }
            return parts.join(" > ");
        };

        const describeNode = (node) => {
            const rect = node.getBoundingClientRect();
            const styles = window.getComputedStyle(node);
            return {
                tagName: node.tagName || "",
                id: node.id || "",
                classes: Array.from(node.classList || []),
                selector: describeSelector(node),
                text: (node.textContent || "").slice(0, 200),
                rect: {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                },
                styles: {
                    color: styles.color,
                    backgroundColor: styles.backgroundColor,
                    fontSize: styles.fontSize
                }
            };
        };

        const updateHighlight = (node) => {
            const box = ensureHighlight();
            const rect = node.getBoundingClientRect();
            box.style.display = "block";
            box.style.left = rect.left + "px";
            box.style.top = rect.top + "px";
            box.style.width = rect.width + "px";
            box.style.height = rect.height + "px";
            const details = describeNode(node);
            const signature = [
                details.selector || details.tagName || "",
                Math.round(rect.x || 0),
                Math.round(rect.y || 0),
                Math.round(rect.width || 0),
                Math.round(rect.height || 0),
            ].join("|");
            if (signature === lastInspectSignature) return;
            lastInspectSignature = signature;
            send("inspect_update", details);
        };

        const enableInspect = () => {
            if (inspectActive) return;
            inspectActive = true;
            hoverHandler = (event) => {
                const target = event.target;
                if (!target || target === highlightEl || target.nodeType !== 1) return;
                pendingNode = target;
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    if (!pendingNode) return;
                    updateHighlight(pendingNode);
                    pendingNode = null;
                });
            };
            clickHandler = (event) => {
                event.preventDefault();
                event.stopPropagation();
            };
            document.addEventListener("mousemove", hoverHandler, true);
            document.addEventListener("click", clickHandler, true);
        };

        const disableInspect = () => {
            if (!inspectActive) return;
            inspectActive = false;
            document.removeEventListener("mousemove", hoverHandler, true);
            document.removeEventListener("click", clickHandler, true);
            hoverHandler = null;
            clickHandler = null;
            pendingNode = null;
            lastInspectSignature = "";
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            hideHighlight();
        };

        window.addEventListener("message", (event) => {
            const data = event.data;
            if (!data || data.source !== "fazide-parent" || data.token !== TOKEN) return;
            if (data.type === "inspect_enable") {
                enableInspect();
                send("inspect_status", { active: true });
            } else if (data.type === "inspect_disable") {
                disableInspect();
                send("inspect_status", { active: false });
            } else if (data.type === "theme_update") {
                const theme = applyThemeSurface(data.payload?.theme);
                send("theme_applied", { theme });
            } else if (data.type === "debug_eval") {
                const expressions = Array.isArray(data.payload?.expressions) ? data.payload.expressions : [];
                const values = {};
                expressions.forEach((expr) => {
                    const source = String(expr || "").trim();
                    if (!source) return;
                    try {
                        // eslint-disable-next-line no-eval
                        const value = eval(source);
                        values[source] = typeof value === "string" ? value : JSON.stringify(value);
                    } catch (err) {
                        values[source] = "[error] " + String(err && err.message ? err.message : err);
                    }
                });
                send("debug_watch", { values });
            }
        });

        send("bridge_ready", { at: Date.now() });
    <\/script>
    `;
}
